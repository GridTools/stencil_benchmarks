#!/usr/bin/env python

import gc
import itertools

import click
import numpy as np
import pandas as pd

from stencil_benchmarks.benchmark import ExecutionError, ParameterError
from stencil_benchmarks.benchmarks_collection.stencils.cuda_hip import (
    basic, horizontal_diffusion)
from stencil_benchmarks.tools import cli as cli_tools, common


def benchmark_domains():
    exponents = list(range(5, 11))
    with cli_tools.report_progress(len(exponents)) as progress:
        for exponent in exponents:
            d = 2**exponent
            yield d, d, 80
            progress()


def block_sizes_for_domain(domain, block_size):
    def valid_block_sizes(d):
        return itertools.takewhile(lambda b: b <= d,
                                   (2**b for b in itertools.count()))

    block_sizes = [
        fixed if fixed is not None else valid_block_sizes(d)
        for d, fixed in zip(domain, block_size)
    ]
    for b in itertools.product(*block_sizes):
        if np.product(b) >= 32:
            yield b


def run_and_get_median(stencil, executions):
    return sorted((stencil.run() for _ in range(executions)),
                  key=lambda x: x['time'])[executions // 2]


def benchmark(stencils_and_kwargs, executions):
    results = []
    for domain in benchmark_domains():
        for name, Stencil, kwargs in stencils_and_kwargs:
            stencil = Stencil(domain=domain, **kwargs)
            result = run_and_get_median(stencil, executions)
            result.update(stencil=name, domain=domain[0])

            results.append(result)

            del stencil
            gc.collect()
    return pd.DataFrame(results)


def blocksize_scan(stencils_and_kwargs, domain, executions):
    results = []
    with cli_tools.report_progress(len(stencils_and_kwargs)) as progress:
        for name, Stencil, kwargs in stencils_and_kwargs:
            kwargs = kwargs.copy()
            for block_size in block_sizes_for_domain(
                    domain, kwargs.pop('block_size', (None, None, None))):
                try:
                    stencil = Stencil(domain=domain,
                                      block_size=block_size,
                                      **kwargs)
                except ParameterError:
                    continue

                try:
                    result = run_and_get_median(stencil, executions)
                except ExecutionError:
                    continue

                result.update({'stencil': name, 'block-size': block_size})
                results.append(result)

                del stencil
                gc.collect()
            progress()
    return pd.DataFrame(results)


@click.group()
def cli():
    pass


def common_kwargs(backend, gpu_architecture, dtype):
    return dict(backend=backend,
                compiler='nvcc' if backend == 'cuda' else 'hipcc',
                gpu_architecture=gpu_architecture,
                verify=False,
                run_twice=True,
                gpu_timers=True,
                alignment=128 if backend == 'cuda' else 64,
                dtype=dtype)


@cli.command()
@click.argument('backend', type=click.Choice(['cuda', 'hip']))
@click.argument('gpu-architecture')
@click.argument('prefix')
@click.option('--executions', '-e', type=int, default=101)
@click.option('--dtype', '-d', default='float64')
def basic_bandwidth(backend, gpu_architecture, prefix, executions, dtype):
    kwargs = common_kwargs(backend, gpu_architecture, dtype)
    kwargs.update(
        loop='3D',
        block_size=(32, 8, 1),
        halo=1,
    )

    stream_kwargs = kwargs.copy()
    stream_kwargs.update(loop='1D', block_size=(1024, 1, 1), halo=0)

    stencils = [('stream', basic.Copy, stream_kwargs),
                ('empty', basic.Empty, kwargs), ('copy', basic.Copy, kwargs),
                ('avg-i', basic.OnesidedAverage, dict(axis=0, **kwargs)),
                ('avg-j', basic.OnesidedAverage, dict(axis=1, **kwargs)),
                ('avg-k', basic.OnesidedAverage, dict(axis=2, **kwargs)),
                ('sym-avg-i', basic.SymmetricAverage, dict(axis=0, **kwargs)),
                ('sym-avg-j', basic.SymmetricAverage, dict(axis=1, **kwargs)),
                ('sym-avg-k', basic.SymmetricAverage, dict(axis=2, **kwargs)),
                ('lap-ij', basic.Laplacian,
                 dict(along_x=True, along_y=True, along_z=False, **kwargs))]

    table = benchmark(stencils, executions)

    table = table.pivot('domain', 'stencil')
    common.write_csv(table['time'], prefix + '-time.csv')
    common.write_csv(table['bandwidth'], prefix + '-bandwidth.csv')


@cli.command()
@click.argument('backend', type=click.Choice(['cuda', 'hip']))
@click.argument('gpu-architecture')
@click.argument('prefix')
@click.argument('domain', type=int, nargs=3)
@click.option('--executions', '-e', type=int, default=3)
@click.option('--dtype', '-d', default='float32')
@click.option('--all-stencils/--fast-stencils-only', '-a')
def horizontal_diffusion_blocksize_scan(backend, gpu_architecture, prefix,
                                        domain, executions, dtype,
                                        all_stencils):
    kwargs = common_kwargs(backend, gpu_architecture, dtype)

    basic_kwargs = dict(**kwargs, block_size=(None, None, [1]))
    jscan_kwargs = dict(**kwargs, block_size=([32], None, [1, 2, 4, 8, 16]))

    stencils = [('on-the-fly', horizontal_diffusion.OnTheFly,
                 dict(**basic_kwargs, loop='3D')),
                ('classic', horizontal_diffusion.Classic, basic_kwargs),
                ('j-scan-otf-aligned', horizontal_diffusion.JScanOtfAligned,
                 jscan_kwargs)]

    if all_stencils:
        stencils += [
            ('j-scan', horizontal_diffusion.JScan, jscan_kwargs),
            ('j-scan-otf', horizontal_diffusion.JScanOtf, jscan_kwargs),
            ('j-scan-shuffle', horizontal_diffusion.JScanShuffle, jscan_kwargs)
        ]

    table = blocksize_scan(stencils, domain, executions)
    common.write_csv(table, prefix + '-raw.csv')

    bestblocks = table.loc[table.groupby('stencil')['time'].idxmin()]
    bestblocks.set_index('stencil', inplace=True)
    common.write_csv(bestblocks, prefix + '-bestblocks.csv')


@cli.command()
@click.argument('backend', type=click.Choice(['cuda', 'hip']))
@click.argument('gpu-architecture')
@click.argument('prefix')
@click.option('--executions', '-e', type=int, default=101)
@click.option('--dtype', '-d', default='float32')
def horizontal_diffusion_bandwidth(backend, gpu_architecture, prefix,
                                   executions, dtype):
    kwargs = common_kwargs(backend, gpu_architecture, dtype)

    otf_kwargs = kwargs.copy()
    classic_kwargs = kwargs.copy()
    jscan_kwargs = kwargs.copy()

    otf_kwargs.update(loop='3D')
    if backend == 'hip':
        otf_kwargs.update(block_size=(128, 4, 1))
        classic_kwargs.update(block_size=(64, 8, 1))
        jscan_kwargs.update(block_size=(64, 4, 1))
    else:
        otf_kwargs.update(block_size=(256, 2, 1))
        classic_kwargs.update(block_size=(32, 16, 1))
        jscan_kwargs.update(block_size=(32, 16, 2))

    stencils = [('on-the-fly', horizontal_diffusion.OnTheFly, otf_kwargs),
                ('classic', horizontal_diffusion.Classic, classic_kwargs),
                ('j-scan-otf-aligned', horizontal_diffusion.JScanOtfAligned,
                 jscan_kwargs)]

    table = benchmark(stencils, executions)

    table = table.pivot('domain', 'stencil')
    common.write_csv(table['time'], prefix + '-time.csv')
    common.write_csv(table['bandwidth'], prefix + '-bandwidth.csv')


cli()
