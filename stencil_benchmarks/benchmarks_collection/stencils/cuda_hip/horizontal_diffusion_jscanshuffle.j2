{% extends "base.j2" %}

{% set block_halo = 2 %}

{% block gpu_kernel_body %}
    const std::ptrdiff_t ib = std::ptrdiff_t(threadIdx.x) - {{ block_halo }};

    const std::ptrdiff_t i = std::ptrdiff_t(blockIdx.x) * {{ block_size[0] }} + ib;
    const std::ptrdiff_t j_min = std::ptrdiff_t(blockIdx.y) * {{ block_size[1] }} - {{ block_halo }};
    const std::ptrdiff_t k = std::ptrdiff_t(blockIdx.z) * {{ block_size[2] }} + threadIdx.z;
    if (k >= {{ domain[2] }})
        return;

    const std::ptrdiff_t ib_max = (blockIdx.x + 1) * {{ block_size[0] }} <= {{ domain[0] }} ? {{ block_size[0] }} : {{ domain[0] }} - blockIdx.x * {{ block_size[0] }};
    const std::ptrdiff_t jb_max = (blockIdx.y + 1) * {{ block_size[1] }} <= {{ domain[1] }} ? {{ block_size[1] }} : {{ domain[1] }} - blockIdx.y * {{ block_size[1] }};
        
    if (ib >= ib_max + {{ block_halo }})
        return;

    std::ptrdiff_t index = i * {{ strides[0] }} + j_min * {{ strides[1] }} + k * {{ strides[2] }};

{%- if backend == "hip" %}
#define SHFL_UP(x) __shfl_up((x), 1)
#define SHFL_DOWN(x) __shfl_down((x), 1)
{%- else %}
#define SHFL_UP(x) __shfl_up_sync(0xffffffff, (x), 1)
#define SHFL_DOWN(x) __shfl_down_sync(0xffffffff, (x), 1)
{%- endif %}

    {{ ctype }} inp_ij, inp_ijp1, inp_ijp2;
    {{ ctype }} lap_ij, lap_ijp1;
    {{ ctype }} fly_ijm1, fly_ij;

    inp_ij = inp[index];
    inp_ijp1 = inp[index + {{ strides[1] }}];

#pragma unroll
    for (std::ptrdiff_t jb = -{{ block_halo }}; jb < {{ block_size[1] }}; ++jb) {
        if (jb < jb_max) {
            inp_ijp2 = inp[index + 2 * {{ strides[1] }}];

            lap_ijp1 = 4 * inp_ijp1 - inp_ij
                                    - inp_ijp2
                                    - SHFL_UP(inp_ijp1)
                                    - SHFL_DOWN(inp_ijp1);

            if (jb >= -1) {
                fly_ij = lap_ijp1 - lap_ij;
                if (fly_ij * (inp_ijp1 - inp_ij) > {{ ctype }}(0))
                    fly_ij = {{ ctype }}(0);
            }

            if (jb >= 0) {
                {{ ctype }} flx_ij = lap_ij - SHFL_UP(lap_ij);
                if (flx_ij * (inp_ij - SHFL_UP(inp_ij)) > {{ ctype }}(0))
                    flx_ij = {{ ctype }}(0);
                const {{ ctype }} flx_ip1j = SHFL_DOWN(flx_ij);

                if (ib >= 0 && ib < ib_max) {
                    out[index] = inp_ij - coeff[index] * (flx_ip1j -
                                                          flx_ij +
                                                          fly_ij -
                                                          fly_ijm1);
                }
            }

            lap_ij = lap_ijp1;
            inp_ij = inp_ijp1;
            inp_ijp1 = inp_ijp2;
            fly_ijm1 = fly_ij;

            index += {{ strides[1] }};
        }
    }
{% endblock gpu_kernel_body %}

{% block kernel_prepare %}
    if ({{ block_size[0] + 2 * block_halo }} != device_properties.warpSize) {
        std::cerr << "only supported block size along first dimension is "
                  << (device_properties.warpSize - {{ 2 * block_halo }}) << std::endl;
        return 0.0;
    }
    block_size = dim3({{ block_size[0] + 2 * block_halo }},
                      1,
                      {{ block_size[2] }});
    grid_size = dim3({{ (domain[0] + block_size[0] - 1) // block_size[0] }},
                     {{ (domain[1] + block_size[1] - 1) // block_size[1] }},
                     {{ (domain[2] + block_size[2] - 1) // block_size[2] }});
{% endblock kernel_prepare %}
