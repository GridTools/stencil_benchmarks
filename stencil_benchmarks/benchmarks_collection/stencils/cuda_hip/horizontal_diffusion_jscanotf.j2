#include <chrono>
#include <cstdint>
#include <iostream>

{%- if backend == "hip" %}
#include <hip/hip_runtime.h>
using hipDeviceProp = hipDeviceProp_t;
{% endif %}

constexpr std::ptrdiff_t block_halo = 2;

__global__ void gpu_kernel(
    {%- for arg in args %}
        {{ ctype }} * __restrict__ {{ arg }}{{ "," if not loop.last }}
    {%- endfor %}
) {
    const std::ptrdiff_t ib = threadIdx.x - block_halo;
    const std::ptrdiff_t block_size_x = warpSize - 2 * block_halo;

    const std::ptrdiff_t i = blockIdx.x * block_size_x + ib;
    const std::ptrdiff_t j_min = blockIdx.y * {{ block_size[1] }} - block_halo;
    const std::ptrdiff_t k = blockIdx.z * {{ block_size[2] }} + threadIdx.z;

    extern __shared__ {{ ctype }} smem[];

    {{ ctype }}* inc = &smem[threadIdx.z * warpSize * 3];

    constexpr std::ptrdiff_t cache_istride = 1;
    const std::ptrdiff_t cache_jstride = warpSize;
    
    const std::ptrdiff_t ib_max = (blockIdx.x + 1) * block_size_x <= {{ domain[0] }} ? block_size_x : {{ domain[0] }} - blockIdx.x * block_size_x;
    const std::ptrdiff_t jb_max = (blockIdx.y + 1) * {{ block_size[1] }} <= {{ domain[1] }} ? {{ block_size[1] }} : {{ domain[1] }} - blockIdx.y * {{ block_size[1] }};

    const std::ptrdiff_t cache_index = (ib + block_halo) * cache_istride;

    {{ ctype }} fly_ijm1;
    {{ ctype }} lap_im1j, lap_ij, lap_ip1j;
    
        
    std::ptrdiff_t index = i * {{ strides[0] }} + j_min * {{ strides[1] }} + k * {{ strides[2] }};

    inc[cache_index] = inp[index];
    inc[cache_index + cache_jstride] = inp[index + {{ strides[1] }}];

    for (std::ptrdiff_t jb = -block_halo; jb < jb_max; ++jb) {
        inc[cache_index + 2 * cache_jstride] = inp[index + 2 * {{ strides[1] }}];
        __syncthreads();

        if (ib >= 0 && ib < ib_max) {
            {{ ctype }} lap_im1jp1 = 4 * inc[cache_index - cache_istride + cache_jstride] -
                                     (inc[cache_index - 2 * cache_istride + cache_jstride] +
                                      inc[cache_index + cache_jstride] +
                                      inc[cache_index - cache_istride + 2 * cache_jstride] +
                                      inc[cache_index - cache_istride]);
            {{ ctype }} lap_ijp1 = 4 * inc[cache_index + cache_jstride] -
                                   (inc[cache_index - cache_istride + cache_jstride] +
                                    inc[cache_index + cache_istride + cache_jstride] +
                                    inc[cache_index + 2 * cache_jstride] +
                                    inc[cache_index]);
            {{ ctype }} lap_ip1jp1 = 4 * inc[cache_index + cache_istride + cache_jstride] -
                                     (inc[cache_index + cache_jstride] +
                                      inc[cache_index + 2 * cache_istride + cache_jstride] +
                                      inc[cache_index + cache_istride + 2 * cache_jstride] +
                                      inc[cache_index + cache_istride]);

            if (jb >= -1) {
                {{ ctype }} fly_ij = lap_ijp1 - lap_ij;
                if (fly_ij * (inc[cache_index + cache_jstride] - inc[cache_index]) > 0) {
                    fly_ij = 0.;
                }            

                if (jb >= 0) {
                    {{ ctype }} flx_ij = lap_ip1j - lap_ij;
                    if (flx_ij * (inc[cache_index + cache_istride] - inc[cache_index]) > 0) {
                        flx_ij = 0.;
                    }

                    {{ ctype }} flx_im1j = lap_ij - lap_im1j;
                    if (flx_im1j * (inc[cache_index] - inc[cache_index - cache_istride]) > 0) {
                        flx_im1j = 0.;
                    }

                    out[index] = inc[cache_index] - coeff[index] * (flx_ij - 
                                                                    flx_im1j +
                                                                    fly_ij -
                                                                    fly_ijm1);
                }

                fly_ijm1 = fly_ij;
            }

            lap_im1j = lap_im1jp1;
            lap_ij = lap_ijp1;
            lap_ip1j = lap_ip1jp1;
        }

        inc[cache_index] = inc[cache_index + cache_jstride];
        inc[cache_index + cache_jstride] = inc[cache_index + 2 * cache_jstride];        

        index += {{ strides[1] }};
    }
}

extern "C" double kernel(
    {%- for arg in args %}
        {{ ctype }} * __restrict__ {{ arg }}{{ "," if not loop.last }}
    {%- endfor %}
) {
    int device;
    {{ backend }}DeviceProp prop;
    {{ backend }}GetDevice(&device);
    {{ backend }}GetDeviceProperties(&prop, device);

    dim3 block_size(prop.warpSize,
                    1,
                    {{ block_size[2] }});
    auto logical_block_size_x = prop.warpSize - 2 * block_halo;
    dim3 grid_size(({{ domain[0] }} + logical_block_size_x - 1) / logical_block_size_x,
                   {{ (domain[1] + block_size[1] - 1) // block_size[1] }},
                   {{ (domain[2] + block_size[2] - 1) // block_size[2] }});

    auto smem_size = sizeof({{ ctype }}) * prop.warpSize * 3 * {{ block_size[2] }};

    using clock = std::chrono::high_resolution_clock;
    auto start = clock::now();

    gpu_kernel<<<grid_size, block_size, smem_size>>>(
        {%- for arg in args %}
            {{ arg }}{{ "," if not loop.last }}
        {%- endfor %}
    );
    {{ backend }}Error_t err;
    if ((err = {{ backend }}GetLastError()) != {{ backend }}Success) {
        std::cerr << "kernel launch failure: " << {{ backend }}GetErrorString(err) << std::endl;
    }
    if ((err = {{ backend }}DeviceSynchronize()) != {{ backend }}Success) {
        std::cerr << "synchronization failure: " << {{ backend }}GetErrorString(err) << std::endl;
    }

    auto stop = clock::now();
    return std::chrono::duration<double>(stop - start).count();
}