{% extends "base.j2" %}

{% block kernel_invoke %}
#pragma omp parallel
  {
    using unaligned_vec_t = {{ ctype }} __attribute__((vector_size({{ vector_size }} * sizeof({{ ctype }})), aligned(sizeof({{ ctype }}))));
    {%- if ctype == 'double' %}
      {%- if alignment > 0 and alignment % (8 * vector_size) == 0 %}
        using vec_t = {{ ctype }} __attribute__((vector_size({{ vector_size }} * sizeof({{ ctype }}))));
      {%- else %}
        using vec_t = unaligned_vec_t;
      {%- endif %}
    {%- else %}
      {%- if alignment > 0 and alignment % (4 * vector_size) == 0 %}
        using vec_t = {{ ctype }} __attribute__((vector_size({{ vector_size }} * sizeof({{ ctype }}))));
      {%- else %}
        using vec_t = unaligned_vec_t;
      {%- endif %}
    {%- endif %}

    alignas({{ alignment }}) {{ ctype }} lap[{{ block_size[1] + 4 }}][{{ (block_size[0] + 4 + 2 * vector_size - 1) // vector_size * vector_size }}];
    alignas({{ alignment }}) {{ ctype }} flx[{{ block_size[1] + 4 }}][{{ (block_size[0] + 4 + 2 * vector_size - 1) // vector_size * vector_size }}];
    alignas({{ alignment }}) {{ ctype }} fly[{{ block_size[1] + 4 }}][{{ (block_size[0] + 4 + 2 * vector_size - 1) // vector_size * vector_size }}];

#pragma omp for collapse(3)
    for (index_t kb = 0; kb < {{ domain[2] }}; kb += {{ block_size[2] }}) {
      for (index_t jb = 0; jb < {{ domain[1] }}; jb += {{ block_size[1] }}) {
        for (index_t ib = 0; ib < {{ domain[0] }}; ib += {{ block_size[0] }}) {
          {%- if block_size[2] > 1 %}
            const index_t kmax = std::min({{ domain[2] }} - kb, (index_t){{ block_size[2] }});
            for (index_t k = 0; k < kmax; ++k) {
          {%- else %}
            const index_t k = 0;
            {
          {%- endif %}
              for (index_t j = -2; j < {{ block_size[1] }} + 2; ++j) {
                index_t i = -2;
                index_t index = (ib + i) * {{ strides[0] }} + (jb + j) * {{ strides[1] }} + (kb + k) * {{ strides[2] }};

                for (; i < 0; ++i) {
                  lap[j + 2][i + {{ vector_size }}] = 4 * inp[index]
                                                        - inp[index - {{ strides[0] }}]
                                                        - inp[index + {{ strides[0] }}]
                                                        - inp[index - {{ strides[1] }}]
                                                        - inp[index + {{ strides[1] }}];
                  index += {{ strides[0] }};
                }

                for (; i < {{ block_size[0] }}; i += {{ vector_size }}) {
                  *(vec_t*)&lap[j + 2][i + {{ vector_size }}] = 4 * *(vec_t*)&inp[index]
                                                              - *(unaligned_vec_t*)&inp[index - {{ strides[0] }}]
                                                              - *(unaligned_vec_t*)&inp[index + {{ strides[0] }}]
                                                              - *(vec_t*)&inp[index - {{ strides[1] }}]
                                                              - *(vec_t*)&inp[index + {{ strides[1] }}];
                  index += {{ vector_size * strides[0] }};
                }

                for (; i < {{ block_size[0] + 2 }}; ++i) {
                  lap[j + 2][i + {{ vector_size }}] = 4 * inp[index]
                                                        - inp[index - {{ strides[0] }}]
                                                        - inp[index + {{ strides[0] }}]
                                                        - inp[index - {{ strides[1] }}]
                                                        - inp[index + {{ strides[1] }}];
                  index += {{ strides[0] }};
                }
              }

              for (index_t j = -1; j < {{ block_size[1] }} + 1; ++j) {
                index_t i = -1;
                index_t index = (ib + i) * {{ strides[0] }} + (jb + j) * {{ strides[1] }} + (kb + k) * {{ strides[2] }};

                for (; i < 0; ++i) {
                  {{ ctype }} flx_ij = lap[j + 2][i + {{ vector_size + 1 }}] - lap[j + 2][i + {{ vector_size }}];
                  flx[j + 2][i + {{ vector_size }}] = flx_ij * (inp[index + {{ strides[0] }}] - inp[index]) > 0 ? 0 : flx_ij;

                  {{ ctype }} fly_ij = lap[j + 3][i + {{ vector_size }}] - lap[j + 2][i + {{ vector_size }}];
                  fly[j + 2][i + {{ vector_size }}] = fly_ij * (inp[index + {{ strides[1] }}] - inp[index]) > 0 ? 0 : fly_ij;

                  index += {{ strides[0] }};
                }

                for (; i < {{ block_size[0] }}; i += {{ vector_size }}) {
                  vec_t flx_ij = *(unaligned_vec_t*)&lap[j + 2][i + {{ vector_size + 1 }}] - *(vec_t*)&lap[j + 2][i + {{ vector_size }}];
                  *(vec_t*)&flx[j + 2][i + {{ vector_size }}] = flx_ij * (*(unaligned_vec_t*)&inp[index + {{ strides[0] }}] - *(vec_t*)&inp[index]) > 0 ? 0 : flx_ij;

                  vec_t fly_ij = *(vec_t*)&lap[j + 3][i + {{ vector_size }}] - *(vec_t*)&lap[j + 2][i + {{ vector_size }}];
                  *(vec_t*)&fly[j + 2][i + {{ vector_size }}] = fly_ij * (*(vec_t*)&inp[index + {{ strides[1] }}] - *(vec_t*)&inp[index]) > 0 ? 0 : fly_ij;

                  index += {{ strides[0] * vector_size }};
                }

                for (; i < {{ block_size[0] + 1 }}; ++i) {
                  {{ ctype }} flx_ij = lap[j + 2][i + {{ vector_size + 1 }}] - lap[j + 2][i + {{ vector_size }}];
                  flx[j + 2][i + {{ vector_size }}] = flx_ij * (inp[index + {{ strides[0] }}] - inp[index]) > 0 ? 0 : flx_ij;

                  {{ ctype }} fly_ij = lap[j + 3][i + {{ vector_size }}] - lap[j + 2][i + {{ vector_size }}];
                  fly[j + 2][i + {{ vector_size }}] = fly_ij * (inp[index + {{ strides[1] }}] - inp[index]) > 0 ? 0 : fly_ij;

                  index += {{ strides[0] }};
                }
              }

              for (index_t j = 0; j < {{ block_size[1] }}; ++j) {
                index_t i = 0;
                index_t index = (ib + i) * {{ strides[0] }} + (jb + j) * {{ strides[1] }} + (kb + k) * {{ strides[2] }};
                for (; i < {{ block_size[0] }}; i += {{ vector_size }}) {
#pragma omp simd
                  for (index_t v = 0; v < {{ vector_size }}; ++v) {
                    out[index + v * {{ strides[0] }}] = inp[index + v * {{ strides[0] }}]
                                                      - coeff[index + v * {{ strides[0] }}]
                                                      * (flx[j + 2][i + {{ vector_size}} + v]
                                                       - flx[j + 2][i + {{ vector_size - 1 }} + v]
                                                       + fly[j + 2][i + {{ vector_size}} + v]
                                                       - fly[j + 1][i + {{ vector_size}} + v]);
                  }

                  index += {{ strides[0] * vector_size }};
                }
              }
            }
        }
      }
    }
  }
{% endblock kernel_invoke %}
