{% extends "base.j2" %}

{% block kernel_invoke %}
#pragma omp parallel for collapse(3)
  for (std::ptrdiff_t ib = 0; ib < {{ sorted_domain[0] }}; ib += {{ sorted_block_size[0] }}) {
    for (std::ptrdiff_t jb = 0; jb < {{ sorted_domain[1] }}; jb += {{ sorted_block_size[1] }}) {
      for (std::ptrdiff_t kb = 0; kb < {{ sorted_domain[2] }}; kb += {{ sorted_block_size[2] }}) {
        {%- if sorted_block_size[0] > 1 %}
          const std::ptrdiff_t imax = std::min((std::ptrdiff_t){{ sorted_domain[0] }}, ib + {{ sorted_block_size[0] }});
          for (std::ptrdiff_t i = ib; i < imax; ++i) {
        {%- else %}
          const std::ptrdiff_t i = ib;
          {
        {%- endif %}
            {%- if sorted_block_size[1] > 1 %}
              const std::ptrdiff_t jmax = std::min((std::ptrdiff_t){{ sorted_domain[1] }}, jb + {{ sorted_block_size[1] }});
              for (std::ptrdiff_t j = jb; j < jmax; ++j) {
            {%- else %}
              const std::ptrdiff_t j = jb;
              {
            {%- endif %}
                {%- if sorted_block_size[2] > 1 %}
                  const std::ptrdiff_t kmax = std::min((std::ptrdiff_t){{ sorted_domain[2] }}, kb + {{ sorted_block_size[2] }});
#pragma omp simd
#ifdef __INTEL_COMPILER
#pragma vector nontemporal
#endif
                  for (std::ptrdiff_t k = kb; k < kmax; ++k) {
                {%- else %}
                  const std::ptrdiff_t k = kb;
                  {
                {%- endif %}
                    std::ptrdiff_t index = i * {{ sorted_strides[0] }} + j * {{ sorted_strides[1] }} + k * {{ sorted_strides[2] }};

                    {{ body }}
                  }
              }
          }
      }
    }
  }
{% endblock kernel_invoke %}