#include <algorithm>
#include <chrono>
#include <cmath>
#include <cstdint>
#include <iostream>

#include <errno.h>
#include <linux/mempolicy.h>
#include <numa.h>
#include <numaif.h>
#include <omp.h>
#include <sched.h>
#include <unistd.h>

template <class T, int N> struct alignas(sizeof(T) * N) simdv {
  using value_t = T;
  static constexpr int n = N;

  T data[N];

  [[gnu::always_inline]] static simdv load(const T *ptr) {
    simdv result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = ptr[i];
    return result;
  }

  [[gnu::always_inline]] static simdv broadcast(T const &t) {
    simdv result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = t;
    return result;
  }

  [[gnu::always_inline]] static simdv where(simdv<bool, N> const& condition,
                                            simdv const& if_true,
                                            simdv const& if_false) {
    simdv result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = condition.data[i] ? if_true.data[i] : if_false.data[i];
    return result;
  }

  [[gnu::always_inline]] void store(T *ptr) const {
#pragma omp simd
    for (int i = 0; i < N; ++i)
      ptr[i] = data[i];
  }

  [[gnu::always_inline]] friend simdv operator+(const simdv &a,
                                                const simdv &b) {
    simdv result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = a.data[i] + b.data[i];
    return result;
  }

  [[gnu::always_inline]] friend simdv operator-(const simdv &a,
                                                const simdv &b) {
    simdv result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = a.data[i] - b.data[i];
    return result;
  }

  [[gnu::always_inline]] friend simdv operator*(const simdv &a,
                                                const simdv &b) {
    simdv result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = a.data[i] * b.data[i];
    return result;
  }

  [[gnu::always_inline]] friend simdv operator/(const simdv &a,
                                                const simdv &b) {
    simdv result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = a.data[i] / b.data[i];
    return result;
  }

  [[gnu::always_inline]] friend simdv<bool, N> operator>(const simdv &a,
                                                         const simdv &b) {
    simdv<bool, N> result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = a.data[i] > b.data[i];
    return result;
  }

  [[gnu::always_inline]] friend simdv<bool, N> operator<(const simdv &a,
                                                         const simdv &b) {
    simdv<bool, N> result;
#pragma omp simd
    for (int i = 0; i < N; ++i)
      result.data[i] = a.data[i] < b.data[i];
    return result;
  }
};

{% block pre_kernel %}
{% endblock pre_kernel %}

{% if numa %}
void move_to_local_numa_domain(void* begin, void* end) {
    std::size_t page_size = getpagesize();

    begin = (void*) ((std::size_t) begin / page_size * page_size);
    end = (void*) ((std::size_t) end / page_size * page_size);
    std::size_t size = (char*) end - (char*) begin;
    if (!size)
        return;

    auto local_node = numa_node_of_cpu(sched_getcpu());
    auto* bitmask = numa_allocate_nodemask();
    numa_bitmask_clearall(bitmask);
    numa_bitmask_setbit(bitmask, local_node);
    if (mbind(begin, size, MPOL_BIND, bitmask->maskp, bitmask->size, MPOL_MF_MOVE | MPOL_MF_STRICT)) {
        auto errsv = errno;
        std::cerr << "mbind failed on OpenMP thread " << omp_get_thread_num()
                  << " (CPU " << sched_getcpu() << ") with error " << strerror(errsv);
    }
    numa_free_nodemask(bitmask);
}
{% endif %}

{% block kernel %}
extern "C" double kernel(
    {% for arg in args %}
        {{ ctype }} * __restrict__ {{ arg }}{{ "," if not loop.last }}
    {% endfor %}
) {
    {% block kernel_prepare %}
    {% endblock kernel_prepare %}

    using clock = std::chrono::high_resolution_clock;
    auto start = clock::now();

    {% block kernel_invoke %}
    {% endblock kernel_invoke %}

    auto stop = clock::now();
    return std::chrono::duration<double>(stop - start).count();
}
{% endblock kernel %}