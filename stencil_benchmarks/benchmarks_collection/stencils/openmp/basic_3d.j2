{% extends "base.j2" %}

{% block kernel_prepare %}
    constexpr index_t last = {{ strides[0] }} * ({{ domain[0] }} - 1) +
                                    {{ strides[1] }} * ({{ domain[1] }} - 1) +
                                    {{ strides[2] }} * ({{ domain[2] }} - 1);

    {% if numa %}
    #pragma omp parallel
    {
        size_t threads = omp_get_num_threads();
        size_t thread = omp_get_thread_num();
        size_t begin = last * thread / threads;
        size_t end = last * (thread + 1) / threads;
        {% for arg in args %}
        move_to_local_numa_domain(&{{ arg }}[begin], &{{ arg }}[end]);
        {% endfor %}
    }
    {% endif %}
{% endblock kernel_prepare %}

{% block kernel_invoke %}
#pragma omp parallel for simd collapse(3)
#ifdef __INTEL_COMPILER
#pragma vector nontemporal
#endif
    for (index_t i = 0; i < {{ sorted_domain[0] }}; ++i) {
        for (index_t j = 0; j < {{ sorted_domain[1] }}; ++j) {
            for (index_t k = 0; k < {{ sorted_domain[2] }}; ++k) {
                index_t index = i * {{ sorted_strides[0] }} + j * {{ sorted_strides[1] }} + k * {{ sorted_strides[2] }};
                {{ body }}
            }
        }
    }
{% endblock kernel_invoke %}
